const AWS = require('aws-sdk');

const FIVE_MINUTES = 300000;

/**
 * @name Parameter
 * @prop {String} name
 * @prop {String} type
 * @prop {String} value
 * @prop {Number} version
 * @prop {String} lastModifiedDate
 * @prop {String} arn
 * @prop {Number} expiresAt
 */
class Parameter {
  constructor(parameterObject, expiresIn) {
    this.parameterObject = parameterObject;
    this.expiresAtTimestamp = Date.now() + expiresIn;
  }

  get name() {
    return this.parameterObject.Name;
  }

  get type() {
    return this.parameterObject.Type;
  }

  get value() {
    return this.parameterObject.Value;
  }

  get version() {
    return this.parameterObject.Version;
  }

  get lastModifiedDate() {
    return this.parameterObject.LastModifiedDate;
  }

  get arn() {
    return this.parameterObject.ARN;
  }

  get expiresAt() {
    return this.expiresAtTimestamp;
  }
}

/**
 * @name ParameterCache
 * @extends Map
 * @example
 * const ParameterCache = require('@elilillyco/aws-layer-ssm-parameters');
 * const cache = new ParameterCache({ prefix: '/ABCDEFGHIJK/', region: 'us-east-2' });
 *
 * async function lambdaHandler(event) {
 *   // Loads parameters using "/ABCDEFGHIJK/" as the base path
 *   if(cache.size === 0) await cache.load();
 *   // Retrieves the cached value of "/ABCDEFGHIJK/my-config"
 *   const myConfigValue = await cache.getValue('my-config');
 *   // Retrieves the value of "log-level" from SSM Parameter Store
 *   const globalLogLevel = await cache.getValue('log-level', '');
 * }
 *
 */
class ParameterCache extends Map {
  /**
   * @param {Object}  [options]
   * @param {String}  [options.prefix=/] Default parameter path prefix
   * @param {Boolean} [options.withDecryption=true] Decrypt SecureString parameters
   * @param {String}  [options.region=us-east-1] AWS Region
   * @param {Number}  [options.expiresIn=FIVE_MINUTES] milliseconds
   */
  constructor(options = {}) {
    super();

    this.prefix = options.prefix === undefined ? '/' : options.prefix;
    this.withDecryption = options.withDecryption === undefined ? true : options.withDecryption;
    this.region = options.region === undefined ? 'us-east-1' : options.region;
    this.expiresIn = options.expiresIn === undefined ? FIVE_MINUTES : options.expiresIn;

    let httpOptions;
    if (process.env.HTTPS_PROXY || process.env.HTTP_PROXY) {
      httpOptions = {
        proxy: process.env.HTTPS_PROXY || process.env.HTTP_PROXY,
      };
    }

    this.ssm = new AWS.SSM({
      region: this.region,
      httpOptions,
    });
  }

  /**
   * Loads multiple parameters based on a path prefix.
   * *Uses the prefix provided when the ParameterCache object was instantiated by default*
   *
   * **Queries the SSM Parameter Store**
   *
   * @param {String} [prefix]
   * @returns {Promise<Number>} Number of items loaded
   * @async
   */
  async load(prefix = this.prefix) {
    const resp = await this.ssm.getParametersByPath({
      Path: prefix,
      Recursive: true,
      WithDecryption: this.withDecryption,
    }).promise();

    let loadCount = 0;
    resp.Parameters.forEach((parameter) => {
      super.set(parameter.Name, new Parameter(parameter, this.expiresIn));
      loadCount += 1;
    });

    return loadCount;
  }

  /**
   * Returns the Parameter object based on a key and path prefix.
   * *Uses the prefix provided when the ParameterCache object was instantiated by default*
   *
   * If '/testPrefix/' is the prefix and 'myValue' is the key, then the `Name` of a returned
   *  parameter would be '/testPrefix/myValue'
   *
   * **Queries the SSM Parameter Store**
   *
   * @param {String} key
   * @param {String} [prefix]
   * @returns {Promise<Parameter>}
   * @async
   */
  async get(key, prefix = this.prefix) {
    const keyPath = `${prefix}${key}`;
    let parameterObj = super.get(keyPath);

    if (parameterObj) {
      if (parameterObj.expiresAt > Date.now()) {
        return parameterObj;
      }
    }

    try {
      const resp = await this.ssm.getParameter({
        Name: keyPath,
        WithDecryption: this.withDecryption,
      }).promise();

      parameterObj = new Parameter(resp.Parameter, this.expiresIn);
      super.set(keyPath, parameterObj);

      return parameterObj;
    } catch (error) {
      if (error.name === 'ParameterNotFound') {
        return null;
      }
      throw error;
    }
  }

  /**
   * Returns the Parameter value based on a key and path prefix.
   * *Uses the prefix provided when the ParameterCache object was instantiated by default*
   *
   * If '/testPrefix/' is the prefix and 'myValue' is the key, then the `Name` of a returned
   *  parameter would be '/testPrefix/myValue'
   *
   * **Queries the SSM Parameter Store**
   *
   * @param {String} key
   * @param {String} [prefix]
   * @returns {Promise<String>}
   * @async
   */
  async getValue(...args) {
    const parameter = await this.get(...args);
    if (parameter) {
      return parameter.value;
    }
    return null;
  }

  /**
   * Returns whether the given parameter exists
   * *Uses the prefix provided when the ParameterCache object was instantiated by default*
   *
   * **Queries the SSM Parameter Store**
   *
   * @param {String} key
   * @param {String} [prefix]
   * @returns {Promise<Boolean>}
   * @async
   */
  async has(...args) {
    return !!(await this.get(...args));
  }

  /**
   * Deletes a value from the cache.
   * **Does not remove the value from the SSM Parameter Store**
   *
   * @param {String} key
   * @param {String} prefix
   * @returns {boolean}
   */
  delete(key, prefix = this.prefix) {
    return super.delete(`${prefix}${key}`);
  }

  /**
   * Clears the key from the cache and then reloads the value from the SSM Parameter Store
   * *Uses the prefix provided when the ParameterCache object was instantiated by default*
   * **Queries the SSM Parameter Store**
   *
   * @param {String} key
   * @param {String} [prefix]
   * @returns {Promise<Parameter>}
   * @async
   */
  async refresh(...args) {
    this.delete(...args);
    return this.get(...args);
  }

  /**
   * Clears the cache of all keys and reloads values from the SSM Parameter Store.
   * *Uses the prefix provided when the ParameterCache object was instantiated by default*
   * **Queries the SSM Parameter Store**
   *
   * @returns {Promise<Number>}
   */
  async refreshAll() {
    this.clearAll();
    return this.load();
  }

  /**
   * Clears the cache of all keys
   */
  clearAll() {
    return this.clear();
  }

  /**
   * Set method is not supported
   * @throws Error
   */
  // eslint-disable-next-line class-methods-use-this
  set() {
    throw new Error('Operation not supported');
  }
}

module.exports = ParameterCache;
